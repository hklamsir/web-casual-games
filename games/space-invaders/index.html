<!DOCTYPE html> <html lang="zh-TW"> <head> <meta charset="UTF-8"> <title>太空入侵者 - 優化版</title> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <style> body { margin: 0; overflow: hidden; background: black; font-family: Arial, sans-serif; color: white; } #gameContainer { position: relative; width: 600px; margin: 0 auto; } #gameCanvas { display: block; background: black; border: 2px solid white; } #info { display: flex; justify-content: space-between; align-items: center; margin: 10px 0; font-size: 22px; width: 100%; } #info span { text-align: left; white-space: nowrap; } #score { width: 130px; } #bestScore { width: 210px; } #level { display: flex; justify-content: center; align-items: center; width: 80px; } #lives { width: 180px; display: flex; justify-content: center; align-items: center; } #lives img { vertical-align: middle; margin-left: 5px; } .controls { display: flex; justify-content: space-between; width: 100%; } .movement-controls { display: flex; gap: 5px; } .controlButton { background-color: #333; border: 1px solid #fff; color: #fff; font-size: 20px; padding: 30px 20px; margin: 8px 0; border-radius: 5px; width: 160px; } .controlButton:active { background-color: #555; } </style> </head> <body> <div id="gameContainer"> <div id="info"> <span id="bestScore">最高分數：0</span> <span id="score">分數：0</span> <span id="level">第 1 關</span> <span id="lives">生命：</span> </div> <canvas id="gameCanvas" width="600" height="600"></canvas> <div class="controls"> <div class="movement-controls"> <button class="controlButton" id="btnLeft">左移</button> <button class="controlButton" id="btnRight">右移</button> </div> <button class="controlButton" id="btnFire">發射子彈</button> </div> </div> <!-- 音效檔案 --> <audio id="bgMusicStart" src="bg_music_start.mp3" loop></audio> <audio id="bgMusicGame" src="bg_music_game.mp3" loop></audio> <audio id="explosionSound" src="explosion.mp3"></audio> <audio id="hitSound" src="hit.mp3"></audio> <script> // ================= 全域變數與狀態 ================= const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d'); // 資訊顯示區 const scoreDisplay = document.getElementById('score'); const bestScoreDisplay = document.getElementById('bestScore'); const levelDisplay = document.getElementById('level'); const livesDisplay = document.getElementById('lives'); /* 遊戲狀態： "start" ：開始畫面（顯示操作說明） "playing" ：遊戲進行中 "levelTransition": 關卡過渡，暫停 2 秒後進入下一關 "victoryWait" ：完成第 10 關後先顯示「成功爆機」3秒 "victory" ：勝利畫面，等待玩家返回開始畫面（點擊Canvas返回也有效） "gameOverWait" ：遊戲失敗時先顯示「Game Over」，等待 2 秒 "gameOver" ：遊戲失敗狀態，等待玩家返回開始畫面（點擊Canvas返回也有效） */ let gameState = "start"; let score = 0; let bestScore = parseInt(localStorage.getItem("bestScore")) || 0; let level = 1; const maxLevel = 10; // ================= 背景星空 ================= let stars = []; const starCount = 100; function initStars() { stars = []; for (let i = 0; i < starCount; i++) { stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, radius: Math.random() * 1.5 + 0.5, speed: Math.random() * 0.5 + 0.2 }); } } function updateStars() { for (let star of stars) { star.y += star.speed; if (star.y > canvas.height) { star.y = 0; star.x = Math.random() * canvas.width; } } } function drawStars() { ctx.fillStyle = "white"; for (let star of stars) { ctx.beginPath(); ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2); ctx.fill(); } } initStars(); // ================= 爆炸效果 ================= let explosions = []; function addExplosion(x, y) { explosions.push({ x: x, y: y, radius: 0, maxRadius: 30, alpha: 1, expansionRate: 1.5, fadeRate: 0.03, color: 'orange' }); const explosionSound = document.getElementById('explosionSound'); explosionSound.currentTime = 0; explosionSound.play(); } function updateExplosions() { for (let i = explosions.length - 1; i >= 0; i--) { let exp = explosions[i]; exp.radius += exp.expansionRate; exp.alpha -= exp.fadeRate; if (exp.alpha <= 0) { explosions.splice(i, 1); } } } function drawExplosions() { for (let exp of explosions) { ctx.save(); ctx.globalAlpha = exp.alpha; ctx.fillStyle = exp.color; ctx.beginPath(); ctx.arc(exp.x, exp.y, exp.radius, 0, Math.PI * 2); ctx.fill(); ctx.restore(); } } // ================= 圖片資源 ================= const titleImage = new Image(); titleImage.src = 'title.png'; const playerImage = new Image(); playerImage.src = 'player.png'; const invaderImage = new Image(); invaderImage.src = 'invader.png'; // 大飛碟圖片（動畫用兩張），更新後尺寸 80×40 const ufoImage1 = new Image(); ufoImage1.src = 'ufo1.png'; const ufoImage2 = new Image(); ufoImage2.src = 'ufo2.png'; let ufoAnimTimer = 0; const ufoAnimInterval = 20; // ================= 玩家與敵人參數 ================= const player = { x: canvas.width / 2 - 22.5, y: canvas.height - 60, width: 45, height: 30, speed: 5, dx: 0, bullets: [], lives: 3, hidden: false }; let invaders = []; const invaderRows = 4; const invaderCols = 10; const invaderWidth = 30; const invaderHeight = 20; const invaderPadding = 10; const offsetX = 50; const offsetY = 50; let invaderDirection = 1; const baseInvaderSpeed = 1; const baseInvaderShootingProbability = 0.005; let invaderSpeed = baseInvaderSpeed; let invaderShootingProbability = baseInvaderShootingProbability; function spawnInvaders() { invaders = []; invaderDirection = 1; for (let r = 0; r < invaderRows; r++) { for (let c = 0; c < invaderCols; c++) { let x = offsetX + c * (invaderWidth + invaderPadding); let y = offsetY + r * (invaderHeight + invaderPadding); invaders.push({ x, y, width: invaderWidth, height: invaderHeight, alive: true }); } } } let invaderBullets = []; const invaderBulletSpeed = 3; const invaderBulletWidth = 5; const invaderBulletHeight = 10; const bulletSpeed = 7; // 大飛碟設定（尺寸 80×40） let ufo = null; const ufoWidth = 80; const ufoHeight = 40; const ufoSpeed = 2; const ufoSpawnProbability = 0.002; let ufoBullets = []; const ufoBulletSpeed = 5; const ufoBulletWidth = 5; const ufoBulletHeight = 10; const ufoShootInterval = 60; // ================= 背景音樂 ================= const bgMusicStart = document.getElementById('bgMusicStart'); const bgMusicGame = document.getElementById('bgMusicGame'); const hitSound = document.getElementById('hitSound'); bgMusicStart.volume = 0.5; bgMusicGame.volume = 0.5; hitSound.volume = 0.6; window.onload = function() { document.getElementById("bestScore").innerText = "最高分數：" + bestScore; bgMusicStart.currentTime = 0; bgMusicStart.play().catch(() => { console.log("自動播放背景音樂失敗，請點擊畫面啟動。"); }); }; // ================= 發射子彈冷卻控制 ================= let lastBulletTime = 0; const bulletCooldown = 300; function tryFireBullet() { const now = Date.now(); if (now - lastBulletTime >= bulletCooldown) { player.bullets.push({ x: player.x + player.width / 2 - 2.5, y: player.y, width: 5, height: 10 }); lastBulletTime = now; } } // ================= 手機按鈕操作 ================= const btnLeft = document.getElementById('btnLeft'); const btnRight = document.getElementById('btnRight'); const btnFire = document.getElementById('btnFire'); btnLeft.addEventListener('touchstart', function(e) { e.preventDefault(); keys['ArrowLeft'] = true; }); btnLeft.addEventListener('touchend', function(e) { e.preventDefault(); keys['ArrowLeft'] = false; }); btnRight.addEventListener('touchstart', function(e) { e.preventDefault(); keys['ArrowRight'] = true; }); btnRight.addEventListener('touchend', function(e) { e.preventDefault(); keys['ArrowRight'] = false; }); btnFire.addEventListener('touchstart', function(e) { e.preventDefault(); tryFireBullet(); }); btnLeft.addEventListener('mousedown', function(e) { e.preventDefault(); keys['ArrowLeft'] = true; }); btnLeft.addEventListener('mouseup', function(e) { e.preventDefault(); keys['ArrowLeft'] = false; }); btnRight.addEventListener('mousedown', function(e) { e.preventDefault(); keys['ArrowRight'] = true; }); btnRight.addEventListener('mouseup', function(e) { e.preventDefault(); keys['ArrowRight'] = false; }); btnFire.addEventListener('mousedown', function(e) { e.preventDefault(); tryFireBullet(); }); // ================= 鍵盤事件 ================= const keys = {}; document.addEventListener('keydown', function(e) { if (gameState === "start") { gameState = "playing"; resetGameVariables(); bgMusicStart.pause(); bgMusicGame.currentTime = 0; bgMusicGame.play(); return; } if (gameState === "victory" || gameState === "gameOver") { gameState = "start"; bgMusicGame.pause(); bgMusicStart.currentTime = 0; bgMusicStart.play(); return; } if (gameState === "playing") { keys[e.key] = true; if (e.key === " " || e.key === "Spacebar") { tryFireBullet(); } } }); document.addEventListener('keyup', function(e) { keys[e.key] = false; }); // 點擊Canvas返回開始畫面（適用於勝利與Game Over狀態） canvas.addEventListener('click', function() { if (gameState === "start") { gameState = "playing"; resetGameVariables(); bgMusicStart.pause(); bgMusicGame.currentTime = 0; bgMusicGame.play(); return; } if (gameState === "gameOver" || gameState === "victory") { gameState = "start"; bgMusicGame.pause(); bgMusicStart.currentTime = 0; bgMusicStart.play(); } }); // ================= 遊戲初始與重置 ================= function resetGameVariables() { score = 0; level = 1; player.lives = 3; player.x = canvas.width / 2 - player.width / 2; player.bullets = []; invaderBullets = []; ufoBullets = []; ufo = null; explosions = []; player.hidden = false; invaderSpeed = baseInvaderSpeed; invaderShootingProbability = baseInvaderShootingProbability; spawnInvaders(); updateInfo(); initStars(); } function updateInfo() { scoreDisplay.textContent = `分數：${score}`; bestScoreDisplay.textContent = `最高分數：${bestScore}`; levelDisplay.textContent = `第 ${level} 關`; let livesHTML = '生命：'; for (let i = 0; i < player.lives; i++) { livesHTML += `<img src="player.png" width="20" height="20" alt="life">`; } livesDisplay.innerHTML = livesHTML; } // ================= 玩家被擊中處理 ================= function playerHit() { if (player.hidden) return; addExplosion(player.x + player.width/2, player.y + player.height/2); // 播放被擊中音效 hitSound.currentTime = 0; hitSound.play(); player.lives--; if (player.lives <= 0) { triggerGameOver(); return; } player.hidden = true; setTimeout(() => { player.hidden = false; }, 1000); } // ================= 關卡過關與勝利處理 ================= function transitionToNextLevel() { gameState = "levelTransition"; player.bullets = []; invaderBullets = []; ufoBullets = []; setTimeout(() => { level++; invaderSpeed = baseInvaderSpeed + (level - 1) * 0.5; invaderShootingProbability = baseInvaderShootingProbability + (level - 1) * 0.002; updateInfo(); spawnInvaders(); ctx.clearRect(0, 0, canvas.width, canvas.height); gameState = "playing"; }, 2000); } function gameVictory() { gameState = "victoryWait"; bgMusicGame.pause(); setTimeout(() => { gameState = "victory"; }, 3000); } function triggerGameOver() { addExplosion(player.x + player.width/2, player.y + player.height/2); gameState = "gameOverWait"; bgMusicGame.pause(); setTimeout(() => { gameState = "gameOver"; }, 2000); } // ================= 更新遊戲物件 ================= function update() { updateStars(); updateExplosions(); if (gameState !== "playing") { return; } if (keys['ArrowLeft'] || keys['a'] || keys['A']) { player.dx = -player.speed; } else if (keys['ArrowRight'] || keys['d'] || keys['D']) { player.dx = player.speed; } else { player.dx = 0; } player.x += player.dx; if (player.x < 0) player.x = 0; if (player.x + player.width > canvas.width) player.x = canvas.width - player.width; for (let i = player.bullets.length - 1; i >= 0; i--) { const bullet = player.bullets[i]; bullet.y -= bulletSpeed; if (bullet.y < 0) { player.bullets.splice(i, 1); continue; } for (let j = 0; j < invaders.length; j++) { const inv = invaders[j]; if (inv.alive && bullet.x < inv.x + 45 && bullet.x + bullet.width > inv.x && bullet.y < inv.y + 45 && bullet.y + bullet.height > inv.y) { inv.alive = false; addExplosion(inv.x + 45/2, inv.y + 45/2); player.bullets.splice(i, 1); score += 10; if (score > bestScore) { bestScore = score; localStorage.setItem("bestScore", bestScore); } break; } } if (ufo && bullet.x < ufo.x + ufoWidth && bullet.x + bullet.width > ufo.x && bullet.y < ufo.y + ufoHeight && bullet.y + bullet.height > ufo.y) { addExplosion(ufo.x + ufoWidth/2, ufo.y + ufoHeight/2); score += 100; ufo = null; player.bullets.splice(i, 1); if (score > bestScore) { bestScore = score; localStorage.setItem("bestScore", bestScore); } continue; } } let moveDown = false; for (let i = 0; i < invaders.length; i++) { const inv = invaders[i]; if (!inv.alive) continue; if (inv.x + 45 >= canvas.width && invaderDirection > 0) { moveDown = true; break; } else if (inv.x <= 0 && invaderDirection < 0) { moveDown = true; break; } } for (let i = 0; i < invaders.length; i++) { const inv = invaders[i]; if (!inv.alive) continue; if (moveDown) { inv.y += invaderHeight; } else { inv.x += invaderSpeed * invaderDirection; } } if (moveDown) { invaderDirection *= -1; } for (let inv of invaders) { if (inv.alive && inv.y + 45 > player.y + 25) { triggerGameOver(); return; } } if (Math.random() < invaderShootingProbability) { const aliveInvaders = invaders.filter(inv => inv.alive); if (aliveInvaders.length > 0) { const shooter = aliveInvaders[Math.floor(Math.random() * aliveInvaders.length)]; invaderBullets.push({ x: shooter.x + 45/2 - invaderBulletWidth/2, y: shooter.y + 45, width: invaderBulletWidth, height: invaderBulletHeight }); } } for (let i = invaderBullets.length - 1; i >= 0; i--) { const bullet = invaderBullets[i]; bullet.y += invaderBulletSpeed; if (bullet.y > canvas.height) { invaderBullets.splice(i, 1); continue; } if ( bullet.x < player.x + player.width && bullet.x + bullet.width > player.x && bullet.y < player.y + player.height && bullet.y + bullet.height > player.y ) { invaderBullets.splice(i, 1); playerHit(); } } if (!ufo && Math.random() < ufoSpawnProbability) { ufo = { x: 0, y: 20, width: ufoWidth, height: ufoHeight, speed: ufoSpeed, shootTimer: 0 }; } if (ufo) { ufo.x += ufo.speed; if (ufo.x > canvas.width) { ufo = null; } else { ufo.shootTimer++; if (ufo.shootTimer >= ufoShootInterval) { for (let i = 0; i < 5; i++) { ufoBullets.push({ x: ufo.x + ufoWidth/2 - ufoBulletWidth/2 + (i - 2) * 10, y: ufo.y + ufoHeight, width: ufoBulletWidth, height: ufoBulletHeight }); } ufo.shootTimer = 0; } ufoAnimTimer++; } } for (let i = ufoBullets.length - 1; i >= 0; i--) { const bullet = ufoBullets[i]; bullet.y += ufoBulletSpeed; if (bullet.y > canvas.height) { ufoBullets.splice(i, 1); continue; } if ( bullet.x < player.x + player.width && bullet.x + bullet.width > player.x && bullet.y < player.y + player.height && bullet.y + bullet.height > player.y ) { ufoBullets.splice(i, 1); playerHit(); } } if (!invaders.some(inv => inv.alive)) { if (level < maxLevel) { transitionToNextLevel(); } else { gameVictory(); return; } } updateInfo(); } function draw() { ctx.clearRect(0, 0, canvas.width, canvas.height); drawStars(); drawExplosions(); if (gameState === "start") { ctx.fillStyle = 'white'; ctx.font = '30px Arial'; ctx.textAlign = 'center'; ctx.drawImage(titleImage, canvas.width/2-150, canvas.height/2 - 200); ctx.fillText('操作說明', canvas.width/2, canvas.height/2 - 40); ctx.font = '20px Arial'; ctx.fillText('使用左側按鈕控制左右移動，右側按鈕發射子彈', canvas.width/2, canvas.height/2); ctx.fillText('鍵盤操作亦可使用左右鍵和空白鍵發射', canvas.width/2, canvas.height/2 + 30); ctx.fillText('完成 10 關即成功爆機', canvas.width/2, canvas.height/2 + 60); ctx.fillText('按任意鍵或螢幕開始遊戲', canvas.width/2, canvas.height/2 + 100); } else if (gameState === "levelTransition") { ctx.fillStyle = 'white'; ctx.font = '50px Arial'; ctx.textAlign = 'center'; ctx.fillText(`Level ${level + 1}`, canvas.width/2, canvas.height/2); } else if (gameState === "victoryWait") { ctx.fillStyle = 'red'; ctx.font = '60px Arial'; ctx.textAlign = 'center'; ctx.fillText('成功爆機', canvas.width/2, canvas.height/2); } else if (gameState === "victory") { ctx.fillStyle = 'red'; ctx.font = '60px Arial'; ctx.textAlign = 'center'; ctx.fillText('成功爆機', canvas.width/2, canvas.height/2); ctx.font = '25px Arial'; ctx.fillStyle = 'white'; ctx.fillText('按任意鍵或點擊屏幕返回開始畫面', canvas.width/2, canvas.height/2 + 50); } else if (gameState === "gameOverWait") { ctx.fillStyle = 'green'; ctx.font = '60px Arial'; ctx.textAlign = 'center'; ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 30); ctx.font = '25px Arial'; ctx.fillText(`完成 ${level-1}關 分數：${score}`, canvas.width/2, canvas.height/2 + 20); } else if (gameState === "gameOver") { ctx.fillStyle = 'green'; ctx.font = '60px Arial'; ctx.textAlign = 'center'; ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 30); ctx.font = '25px Arial'; ctx.fillText(`完成 ${level-1}關 分數：${score}`, canvas.width/2, canvas.height/2 + 20); ctx.fillText('按任意鍵或點擊屏幕返回開始畫面', canvas.width/2, canvas.height/2 + 60); } else if (gameState === "playing") { if (!player.hidden) { ctx.drawImage(playerImage, player.x, player.y, player.width, player.height); } ctx.fillStyle = 'red'; for (let bullet of player.bullets) { ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height); } for (let inv of invaders) { if (inv.alive) { ctx.drawImage(invaderImage, inv.x, inv.y, 45, 45); } } ctx.fillStyle = 'yellow'; for (let bullet of invaderBullets) { ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height); } if (ufo) { let currentUfoImage = (ufoAnimTimer % (ufoAnimInterval * 2) < ufoAnimInterval) ? ufoImage1 : ufoImage2; ctx.drawImage(currentUfoImage, ufo.x, ufo.y, ufoWidth, ufoHeight); } ctx.fillStyle = 'orange'; for (let bullet of ufoBullets) { ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height); } } } function gameLoop() { update(); draw(); requestAnimationFrame(gameLoop); } playerImage.onload = function() { gameLoop(); }; </script> </body> </html>