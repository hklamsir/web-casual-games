<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <title>å¤ªç©ºå…¥ä¾µè€… - å„ªåŒ–ç‰ˆ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
      font-family: Arial, sans-serif;
      color: white;
    }
    #gameContainer {
      position: relative;
      width: 100%;
      max-width: 600px;
      margin: 0 auto;
    }
    #gameCanvas {
      display: block;
      background: black;
      border: 2px solid white;
      width: 100%;
      height: auto;
    }
    #info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 10px 0;
      font-size: 16px; /* Slightly smaller for mobile */
      width: 100%;
      padding: 0 10px;
      box-sizing: border-box;
    }
    #info span {
      text-align: left;
      white-space: nowrap;
    }
    .controls {
      display: flex;
      justify-content: space-between;
      width: 100%;
      padding: 0 10px;
      box-sizing: border-box;
      margin-top: 10px;
    }
    .movement-controls {
      display: flex;
      gap: 10px;
      width: 60%;
    }
    .controlButton {
      background-color: #333;
      border: 1px solid #fff;
      color: #fff;
      font-size: 18px;
      padding: 20px 0; /* Vertical padding */
      border-radius: 10px;
      width: 100%; /* Fill flex space */
      touch-action: manipulation; /* Disable double-tap zoom */
    }
    .controlButton:active {
      background-color: #555;
    }
    #btnFire {
      width: 35%; /* Fire button width */
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <div id="info">
      <span id="score">åˆ†æ•¸ï¼š0</span>
      <span id="level">é—œå¡ 1</span>
      <span id="lives">ç”Ÿå‘½ï¼š3</span>
    </div>

    <canvas id="gameCanvas" width="600" height="600"></canvas>
    
    <div class="controls">
      <div class="movement-controls">
        <button class="controlButton" id="btnLeft">â†</button>
        <button class="controlButton" id="btnRight">â†’</button>
      </div>
      <button class="controlButton" id="btnFire">ğŸ”¥</button>
    </div>
  </div>

  <!-- éŸ³æ•ˆæª”æ¡ˆ -->
  <audio id="bgMusicStart" src="bg_music_start.mp3" loop></audio>
  <audio id="bgMusicGame" src="bg_music_game.mp3" loop></audio>
  <audio id="explosionSound" src="explosion.mp3"></audio>
  <audio id="hitSound" src="hit.mp3"></audio>
  <audio id="shootSound" src="shoot.mp3"></audio>

  <script>
    // ================= å…¨åŸŸè®Šæ•¸èˆ‡ç‹€æ…‹ =================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // è³‡è¨Šé¡¯ç¤ºå€
    const scoreDisplay = document.getElementById('score');
    const levelDisplay = document.getElementById('level');
    const livesDisplay = document.getElementById('lives');

    /* éŠæˆ²ç‹€æ…‹ï¼š
         "start"          ï¼šé–‹å§‹ç•«é¢
         "playing"        ï¼šéŠæˆ²é€²è¡Œä¸­
         "levelTransition": é—œå¡éæ¸¡
         "victoryWait"    ï¼šå‹åˆ©ç­‰å¾…
         "victory"        ï¼šå‹åˆ©ç•«é¢
         "gameOverWait"   ï¼šå¤±æ•—ç­‰å¾…
         "gameOver"       ï¼šå¤±æ•—ç•«é¢
    */
    let gameState = "start";
    let score = 0;
    let bestScore = parseInt(localStorage.getItem("bestScore")) || 0;
    let level = 1;
    const maxLevel = 10;

    // ================= èƒŒæ™¯æ˜Ÿç©º =================
    let stars = [];
    const starCount = 100;
    function initStars() {
      stars = [];
      for (let i = 0; i < starCount; i++) {
        stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          radius: Math.random() * 1.5 + 0.5,
          speed: Math.random() * 0.5 + 0.2
        });
      }
    }
    function updateStars() {
      for (let star of stars) {
        star.y += star.speed;
        if (star.y > canvas.height) {
          star.y = 0;
          star.x = Math.random() * canvas.width;
        }
      }
    }
    function drawStars() {
      ctx.fillStyle = "white";
      for (let star of stars) {
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    initStars();

    // ================= çˆ†ç‚¸æ•ˆæœ =================
    let explosions = [];
    function addExplosion(x, y) {
      explosions.push({
        x: x,
        y: y,
        radius: 0,
        maxRadius: 30,
        alpha: 1,
        expansionRate: 1.5,
        fadeRate: 0.03,
        color: 'orange'
      });
      const explosionSound = document.getElementById('explosionSound');
      if (explosionSound) {
          explosionSound.currentTime = 0;
          explosionSound.play().catch(e => {});
      }
    }
    function updateExplosions() {
      for (let i = explosions.length - 1; i >= 0; i--) {
        let exp = explosions[i];
        exp.radius += exp.expansionRate;
        exp.alpha -= exp.fadeRate;
        if (exp.alpha <= 0) {
          explosions.splice(i, 1);
        }
      }
    }
    function drawExplosions() {
      for (let exp of explosions) {
        ctx.save();
        ctx.globalAlpha = exp.alpha;
        ctx.fillStyle = exp.color;
        ctx.beginPath();
        ctx.arc(exp.x, exp.y, exp.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    // ================= åœ–ç‰‡è³‡æº =================
    const titleImage = new Image();
    titleImage.src = 'title.png';
    const playerImage = new Image();
    playerImage.src = 'player.png';
    const invaderImage = new Image();
    invaderImage.src = 'invader.png';
    
    const ufoImage1 = new Image();
    ufoImage1.src = 'ufo1.png';
    const ufoImage2 = new Image();
    ufoImage2.src = 'ufo2.png';
    
    let ufoAnimTimer = 0;
    const ufoAnimInterval = 20;

    // ================= ç©å®¶èˆ‡æ•µäººåƒæ•¸ =================
    const player = {
      x: canvas.width / 2 - 22.5,
      y: canvas.height - 60,
      width: 45,
      height: 30,
      speed: 5,
      dx: 0,
      bullets: [],
      lives: 3,
      hidden: false
    };
    let invaders = [];
    const invaderRows = 4;
    const invaderCols = 10;
    
    // Updated Logic: Unified Size
    const invaderWidth = 40; 
    const invaderHeight = 30;
    const invaderPadding = 10;
    const offsetX = 30; // Adjusted for wider invaders
    const offsetY = 50;
    
    let invaderDirection = 1;
    const baseInvaderSpeed = 1;
    const baseInvaderShootingProbability = 0.005;
    let invaderSpeed = baseInvaderSpeed;
    let invaderShootingProbability = baseInvaderShootingProbability;

    function spawnInvaders() {
      invaders = [];
      invaderDirection = 1;
      for (let r = 0; r < invaderRows; r++) {
        for (let c = 0; c < invaderCols; c++) {
          let x = offsetX + c * (invaderWidth + invaderPadding);
          let y = offsetY + r * (invaderHeight + invaderPadding);
          invaders.push({ x, y, width: invaderWidth, height: invaderHeight, alive: true });
        }
      }
    }
    
    let invaderBullets = [];
    const invaderBulletSpeed = 3;
    const invaderBulletWidth = 5;
    const invaderBulletHeight = 10;
    const bulletSpeed = 7;

    let ufo = null;
    const ufoWidth = 80;
    const ufoHeight = 40;
    const ufoSpeed = 2;
    const ufoSpawnProbability = 0.002;
    let ufoBullets = [];
    const ufoBulletSpeed = 5;
    const ufoBulletWidth = 5;
    const ufoBulletHeight = 10;
    const ufoShootInterval = 60;

    // ================= éŸ³æ¨‚ =================
    const bgMusicStart = document.getElementById('bgMusicStart');
    const bgMusicGame = document.getElementById('bgMusicGame');
    const hitSound = document.getElementById('hitSound');
    if (bgMusicStart) bgMusicStart.volume = 0.5;
    if (bgMusicGame) bgMusicGame.volume = 0.5;
    if (hitSound) hitSound.volume = 0.6;
    
    window.addEventListener('load', function() {
        if (bgMusicStart) {
            bgMusicStart.currentTime = 0;
            bgMusicStart.play().catch(() => {});
        }
        gameLoop();
    });

    // ================= ç™¼å°„æ§åˆ¶ =================
    let lastBulletTime = 0;
    const bulletCooldown = 300;
    function tryFireBullet() {
      const now = Date.now();
      if (now - lastBulletTime >= bulletCooldown) {
        player.bullets.push({
          x: player.x + player.width / 2 - 2.5,
          y: player.y,
          width: 5,
          height: 10
        });
        const shootSound = document.getElementById('shootSound');
        if (shootSound) {
          shootSound.currentTime = 0;
          shootSound.play().catch(e => {});
        }
        lastBulletTime = now;
      }
    }

    // ================= è¼¸å…¥æ§åˆ¶ =================
    const btnLeft = document.getElementById('btnLeft');
    const btnRight = document.getElementById('btnRight');
    const btnFire = document.getElementById('btnFire');
    
    const keys = {};

    function setupTouchButton(btn, key) {
        if (!btn) return;
        btn.addEventListener('touchstart', (e) => { e.preventDefault(); keys[key] = true; });
        btn.addEventListener('touchend', (e) => { e.preventDefault(); keys[key] = false; });
        btn.addEventListener('mousedown', (e) => { keys[key] = true; });
        btn.addEventListener('mouseup', (e) => { keys[key] = false; });
        btn.addEventListener('mouseleave', (e) => { keys[key] = false; });
    }

    setupTouchButton(btnLeft, 'ArrowLeft');
    setupTouchButton(btnRight, 'ArrowRight');
    
    if (btnFire) {
        const fire = (e) => { e.preventDefault(); tryFireBullet(); };
        btnFire.addEventListener('touchstart', fire);
        btnFire.addEventListener('mousedown', fire);
    }

    document.addEventListener('keydown', function(e) {
      if (gameState === "start") {
        gameState = "playing";
        resetGameVariables();
        if (bgMusicStart) bgMusicStart.pause();
        if (bgMusicGame) { bgMusicGame.currentTime = 0; bgMusicGame.play().catch(() => {}); }
        return;
      }
      if (gameState === "victory" || gameState === "gameOver") {
        gameState = "start";
        if (bgMusicGame) bgMusicGame.pause();
        if (bgMusicStart) { bgMusicStart.currentTime = 0; bgMusicStart.play().catch(() => {}); }
        return;
      }
      if (gameState === "playing") {
        keys[e.key] = true;
        if (e.key === " " || e.key === "Spacebar") tryFireBullet();
      }
    });
    
    document.addEventListener('keyup', function(e) { keys[e.key] = false; });

    canvas.addEventListener('click', function() {
      if (gameState === "start") {
        gameState = "playing";
        resetGameVariables();
        if (bgMusicStart) bgMusicStart.pause();
        if (bgMusicGame) { bgMusicGame.currentTime = 0; bgMusicGame.play().catch(() => {}); }
        return;
      }
      if (gameState === "gameOver" || gameState === "victory") {
        gameState = "start";
        if (bgMusicGame) bgMusicGame.pause();
        if (bgMusicStart) { bgMusicStart.currentTime = 0; bgMusicStart.play().catch(() => {}); }
      }
    });

    function resetGameVariables() {
      score = 0;
      level = 1;
      player.lives = 3;
      player.x = canvas.width / 2 - player.width / 2;
      player.bullets = [];
      invaderBullets = [];
      ufoBullets = [];
      ufo = null;
      explosions = [];
      player.hidden = false;
      invaderSpeed = baseInvaderSpeed;
      invaderShootingProbability = baseInvaderShootingProbability;
      spawnInvaders();
      updateInfo();
      initStars();
    }
    
    function updateInfo() {
      if (scoreDisplay) scoreDisplay.textContent = `åˆ†æ•¸ï¼š${score}`;
      if (levelDisplay) levelDisplay.textContent = `é—œå¡ ${level}`;
      if (livesDisplay) livesDisplay.textContent = `ç”Ÿå‘½ï¼š${player.lives}`;
    }

    function playerHit() {
      if (player.hidden) return;
      addExplosion(player.x + player.width/2, player.y + player.height/2);
      if (hitSound) { hitSound.currentTime = 0; hitSound.play().catch(() => {}); }
      player.lives--;
      updateInfo();
      if (player.lives <= 0) {
        triggerGameOver();
        return;
      }
      player.hidden = true;
      setTimeout(() => { player.hidden = false; }, 1000);
    }

    function transitionToNextLevel() {
      gameState = "levelTransition";
      player.bullets = [];
      invaderBullets = [];
      ufoBullets = [];
      setTimeout(() => {
        level++;
        invaderSpeed = baseInvaderSpeed + (level - 1) * 0.5;
        invaderShootingProbability = baseInvaderShootingProbability + (level - 1) * 0.002;
        updateInfo();
        spawnInvaders();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        gameState = "playing";
      }, 2000);
    }
    
    function gameVictory() {
      gameState = "victoryWait";
      if (bgMusicGame) bgMusicGame.pause();
      setTimeout(() => { gameState = "victory"; }, 3000);
    }
    
    function triggerGameOver() {
      addExplosion(player.x + player.width/2, player.y + player.height/2);
      gameState = "gameOverWait";
      if (bgMusicGame) bgMusicGame.pause();
      setTimeout(() => { gameState = "gameOver"; }, 2000);
    }

    function update() {
      updateStars();
      updateExplosions();
      if (gameState !== "playing") return;

      if (keys['ArrowLeft'] || keys['a'] || keys['A']) player.dx = -player.speed;
      else if (keys['ArrowRight'] || keys['d'] || keys['D']) player.dx = player.speed;
      else player.dx = 0;

      player.x += player.dx;
      if (player.x < 0) player.x = 0;
      if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;

      // Player Bullets
      for (let i = player.bullets.length - 1; i >= 0; i--) {
        const bullet = player.bullets[i];
        bullet.y -= bulletSpeed;
        if (bullet.y < 0) {
          player.bullets.splice(i, 1);
          continue;
        }
        
        // Invader Collision
        for (let j = 0; j < invaders.length; j++) {
          const inv = invaders[j];
          if (inv.alive &&
              bullet.x < inv.x + inv.width &&
              bullet.x + bullet.width > inv.x &&
              bullet.y < inv.y + inv.height &&
              bullet.y + bullet.height > inv.y) {
            inv.alive = false;
            addExplosion(inv.x + inv.width/2, inv.y + inv.height/2);
            player.bullets.splice(i, 1);
            score += 10;
            if (score > bestScore) {
              bestScore = score;
              localStorage.setItem("bestScore", bestScore);
            }
            break;
          }
        }
        
        // UFO Collision
        if (ufo &&
            bullet.x < ufo.x + ufoWidth &&
            bullet.x + bullet.width > ufo.x &&
            bullet.y < ufo.y + ufoHeight &&
            bullet.y + bullet.height > ufo.y) {
          addExplosion(ufo.x + ufoWidth/2, ufo.y + ufoHeight/2);
          score += 100;
          ufo = null;
          player.bullets.splice(i, 1);
          if (score > bestScore) {
            bestScore = score;
            localStorage.setItem("bestScore", bestScore);
          }
          continue;
        }
      }

      // Invader Movement
      let moveDown = false;
      for (let inv of invaders) {
        if (!inv.alive) continue;
        if (inv.x + inv.width >= canvas.width && invaderDirection > 0) {
          moveDown = true;
          break;
        } else if (inv.x <= 0 && invaderDirection < 0) {
          moveDown = true;
          break;
        }
      }
      
      if (moveDown) invaderDirection *= -1;
      
      for (let inv of invaders) {
        if (!inv.alive) continue;
        if (moveDown) inv.y += invaderHeight;
        else inv.x += invaderSpeed * invaderDirection;
        
        if (inv.y + inv.height > player.y + 25) { // Game Over Line
          triggerGameOver();
          return;
        }
      }

      // Invader Shooting
      if (Math.random() < invaderShootingProbability) {
        const aliveInvaders = invaders.filter(inv => inv.alive);
        if (aliveInvaders.length > 0) {
          const shooter = aliveInvaders[Math.floor(Math.random() * aliveInvaders.length)];
          invaderBullets.push({
            x: shooter.x + shooter.width/2 - invaderBulletWidth/2,
            y: shooter.y + shooter.height,
            width: invaderBulletWidth,
            height: invaderBulletHeight
          });
        }
      }
      
      for (let i = invaderBullets.length - 1; i >= 0; i--) {
        const bullet = invaderBullets[i];
        bullet.y += invaderBulletSpeed;
        if (bullet.y > canvas.height) {
          invaderBullets.splice(i, 1);
          continue;
        }
        if (bullet.x < player.x + player.width &&
            bullet.x + bullet.width > player.x &&
            bullet.y < player.y + player.height &&
            bullet.y + bullet.height > player.y) {
          invaderBullets.splice(i, 1);
          playerHit();
        }
      }

      // UFO
      if (!ufo && Math.random() < ufoSpawnProbability) {
        ufo = { x: 0, y: 20, width: ufoWidth, height: ufoHeight, speed: ufoSpeed, shootTimer: 0 };
      }
      if (ufo) {
        ufo.x += ufo.speed;
        if (ufo.x > canvas.width) ufo = null;
        else {
          ufo.shootTimer++;
          if (ufo.shootTimer >= ufoShootInterval) {
            for (let i = 0; i < 5; i++) {
              ufoBullets.push({
                x: ufo.x + ufoWidth/2 - ufoBulletWidth/2 + (i - 2) * 10,
                y: ufo.y + ufoHeight,
                width: ufoBulletWidth,
                height: ufoBulletHeight
              });
            }
            ufo.shootTimer = 0;
          }
          ufoAnimTimer++;
        }
      }
      for (let i = ufoBullets.length - 1; i >= 0; i--) {
        const bullet = ufoBullets[i];
        bullet.y += ufoBulletSpeed;
        if (bullet.y > canvas.height) {
          ufoBullets.splice(i, 1);
          continue;
        }
        if (bullet.x < player.x + player.width &&
            bullet.x + bullet.width > player.x &&
            bullet.y < player.y + player.height &&
            bullet.y + bullet.height > player.y) {
          ufoBullets.splice(i, 1);
          playerHit();
        }
      }

      if (!invaders.some(inv => inv.alive)) {
        if (level < maxLevel) transitionToNextLevel();
        else { gameVictory(); return; }
      }
      updateInfo();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawStars();
      drawExplosions();
      
      // Start Screen
      if (gameState === "start") {
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        
        if (titleImage && titleImage.complete && titleImage.naturalWidth > 0) {
            ctx.drawImage(titleImage, canvas.width/2-150, canvas.height/2 - 200); 
        } else {
             ctx.font = '50px Arial';
             ctx.fillText('å¤ªç©ºå…¥ä¾µè€…', canvas.width/2, canvas.height/2 - 100);
        }
        
        ctx.font = '30px Arial';
        ctx.fillText('æ“ä½œèªªæ˜', canvas.width/2, canvas.height/2 - 40);
        ctx.font = '20px Arial';
        ctx.fillText('å·¦/å³ç§»å‹•ï¼šæŒ‰éˆ•æˆ–éµç›¤', canvas.width/2, canvas.height/2);
        ctx.fillText('ç™¼å°„ï¼šæŒ‰éˆ•æˆ–ç©ºç™½éµ', canvas.width/2, canvas.height/2 + 30);
        ctx.fillText('é»æ“Šç•«é¢é–‹å§‹éŠæˆ²', canvas.width/2, canvas.height/2 + 80);
      }
      
      // Playing
      else if (gameState === "playing") {
        if (!player.hidden && playerImage.complete) {
          ctx.drawImage(playerImage, player.x, player.y, player.width, player.height);
        } else if (!player.hidden) {
            // Fallback
            ctx.fillStyle = 'cyan';
            ctx.fillRect(player.x, player.y, player.width, player.height);
        }

        ctx.fillStyle = '#ff3333';
        for (let bullet of player.bullets) ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);

        for (let inv of invaders) {
          if (inv.alive) {
              if (invaderImage.complete) ctx.drawImage(invaderImage, inv.x, inv.y, inv.width, inv.height);
              else { ctx.fillStyle = 'green'; ctx.fillRect(inv.x, inv.y, inv.width, inv.height); }
          }
        }

        ctx.fillStyle = 'yellow';
        for (let bullet of invaderBullets) ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);

        if (ufo) {
          let img = (ufoAnimTimer % (ufoAnimInterval * 2) < ufoAnimInterval) ? ufoImage1 : ufoImage2;
          if (img.complete) ctx.drawImage(img, ufo.x, ufo.y, ufoWidth, ufoHeight);
          else { ctx.fillStyle = 'red'; ctx.fillRect(ufo.x, ufo.y, ufoWidth, ufoHeight); }
        }

        ctx.fillStyle = 'orange';
        for (let bullet of ufoBullets) ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
      }
      
      // Other States
      else if (gameState === "levelTransition") {
        ctx.fillStyle = 'white'; ctx.font = '50px Arial'; ctx.textAlign = 'center';
        ctx.fillText(`Level ${level + 1}`, canvas.width/2, canvas.height/2);
      }
      else if (gameState === "victory" || gameState === "victoryWait") {
        ctx.fillStyle = 'red'; ctx.font = '60px Arial'; ctx.textAlign = 'center';
        ctx.fillText('æˆåŠŸçˆ†æ©Ÿ!', canvas.width/2, canvas.height/2);
        if(gameState === "victory") {
            ctx.font = '25px Arial'; ctx.fillStyle = 'white';
            ctx.fillText('é»æ“Šè¿”å›ä¸»ç•«é¢', canvas.width/2, canvas.height/2 + 50);
        }
      }
      else if (gameState === "gameOver" || gameState === "gameOverWait") {
        ctx.fillStyle = 'green'; ctx.font = '60px Arial'; ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 30);
        ctx.font = '25px Arial';
        ctx.fillText(`åˆ†æ•¸ï¼š${score}`, canvas.width/2, canvas.height/2 + 20);
        if(gameState === "gameOver") {
            ctx.fillText('é»æ“Šè¿”å›ä¸»ç•«é¢', canvas.width/2, canvas.height/2 + 60);
        }
      }
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }
  </script>
</body>
</html>
